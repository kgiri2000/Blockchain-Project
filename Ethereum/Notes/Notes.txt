Tree:
    Hierarchical data structure where each node can have a children, root is top most node, leaves are 
    nodes with no children.
Trie(Prefix Tree)
    Special kind of tree used to store key-value pairs, usually where keys are strings or sequences.
    Each path from root to leaf corresponds to a key.
    The value is stores at the end.
            (root)
             c/  \
             c
            a/
            t/\r
        cat     car

Merkel Tree 
    Hash tree used for data verification and synchronization.
    Hash Functions: maps an input to a fixed output called Hash
    In binary merkel tree, the top hash is the hash of the entire tree.
    The root hash is used as the fingerprint for the entire data.
    Each leaf node store data( r.g, transcation)
    Each non-leaf node stores the hash of its children
    The root hash commits to all data


Patricia Trie ( radix Tree)
    Optimized trie:
    - Instead of storing every single character as a node, it compresses chain of nodes with a single child
    - space-efficient

Merkel  Patricia Trie(MPT)
    - efficient prefix storage
    - Each node is hash 

World State MPT Trie(StateRoot)
    Global State Trie that has snapshot of the current state of the enture network. These tries stires a mapping 
    between an accound addresses(EOAs and smart contracts) and their corresponding account states. 
    Account state:  nonce, balance, storagRoot, codeHash
        storageRoot Trie: For smart contracts
Transaction Trie:
    - store all the txn included in a given block.
    - Each block has it's own trie.
    - nonce, gasPrice, gasLimit, to, value, signature(v,r,s), data
    - Key = transcation's index = RLP(i)
    - Value = RLP-encoded transaction object(TransactionObject)
    - Insert(key, value) into MPT


Receipt Trie:
    - Each transaction produces a transaction Receipt
    - Fields
        - status(0 or 1)
        - cumulativeGasUsed
        - logsBloom(Bloom filter of logs/events generated by this txn)
        - logs[](list of logs generated by contract execution) { addresses, topics[], data}
    - key, value = Insert(key, value) into MPT
    - Proof of execution
    - Light client can check logs/events without replaying all transactions
    - Bloom filters let you quickly scan for relevant lofs across blocks


    
Contract Accounts vs User Accounts
    1. Externally Owned Account(EOA)
        -Controlled by private key(like your wallet)
        -Fields: nonce, balance, codeHash = empty, storageRoot= empty
    2. Contract Account
        - Controlled by code (EVM bytecode stored at that address)
        - Fields:
            -nonce(count of contract creations by that account)
            -balance(can still hold ETH)
            -codeHash (hash of its code)
            -storageRoot(roots of its own private storage trie)
    
How Contracts Get onto the BlockChain:
    - Created by spending a special  transcation with no to address and containing EVM bytecode in the data 
        Fields
    - Can send any transactions which will then execute the code

Storage Trie
    Key =  32-byte slot identifier
    Value = 32-byte word(any data the contract wants to store)

contract PiggyBank {
    address public ownerl //slot 0
    uint256 public balance; //slot 1   
}
    - Contract deployed at address: 0xDEAD....BEEF
    - In State Trie there is now a contract account for this address

    State Trie(global)
        -key: 0xYourEOA ->{nonce, balance,  ...}
        -key: 0xAliceEOA -> {nonce, balance, ...}
        -key: 0xDEAD...BEEF -> Contract Account
                                -nonce =1
                                -balance = 5 ETH
                                -codeHash= hash(PiggyBank bytecode)
                                -storageRoot = hash(root of the Storage Trie)
    

    Storage Trie
        - key: 0x000....000 -> value 0x0000.. <owner address>
        - key: 0x000....001 -> value: 0x000...00000 (balance)

Tx data field encodes which function + arguments
First 4 bytes = function selector(keccak256(signature))
Rest = arguments, padded to 32 bytes( ABI encoding)
EVM dispatches based on the selector and runs the correct function


